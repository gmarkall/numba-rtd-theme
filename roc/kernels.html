

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>5.2. Writing HSA Kernels &mdash; Numba 0.49.0dev0+639.ga41f4317f.dirty documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/numba-blue-icon-rgb.svg"/>
  
  
  
    <link rel="canonical" href="http://numba.pydata.org/numba-doc/latest/index.htmlroc/kernels.html"/>
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/rtd-overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5.3. Memory management" href="memory.html" />
    <link rel="prev" title="5.1. Overview" href="overview.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #00A3E0" >
          

          
            <a href="../index.html" class="icon icon-home"> Numba
          

          
            
            <img src="../_static/numba-white-icon-rgb.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.49
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">1. User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">2. Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cuda/index.html">3. Numba for CUDA GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cuda-reference/index.html">4. CUDA Python Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">5. Numba for AMD ROC GPUs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="overview.html">5.1. Overview</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">5.2. Writing HSA Kernels</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">5.2.1. Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#introduction-for-cuda-programmers">5.2.2. Introduction for CUDA Programmers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kernel-declaration">5.2.3. Kernel declaration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kernel-invocation">5.2.4. Kernel invocation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#choosing-the-workgroup-size">5.2.4.1. Choosing the workgroup size</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multi-dimensional-workgroup-and-grid">5.2.4.2. Multi-dimensional workgroup and grid</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#workitem-positioning">5.2.5. WorkItem positioning</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="memory.html">5.3. Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-functions.html">5.4. Writing Device Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="intrinsics.html">5.5. Supported Atomic Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-management.html">5.6. The Agents</a></li>
<li class="toctree-l2"><a class="reference internal" href="ufunc.html">5.7. ROC Ufuncs and Generalized Ufuncs</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html">5.8. Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../extending/index.html">6. Extending Numba</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer/index.html">7. Developer Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proposals/index.html">8. Numba Enhancement Proposals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">9. Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">10. Release Notes</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Numba</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">5. Numba for AMD ROC GPUs</a> &raquo;</li>
        
      <li>5.2. Writing HSA Kernels</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/roc/kernels.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="writing-hsa-kernels">
<h1>5.2. Writing HSA Kernels<a class="headerlink" href="#writing-hsa-kernels" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>5.2.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>HSA provides an execution model similar to OpenCL.  Instructions are executed
in parallel by a group of hardware threads.  In some way, this is similar to
<em>single-instruction-multiple-data</em> (SIMD) model but with the convenience that
the fine-grain scheduling is hidden from the programmer instead of programming
with SIMD vectors as a data structure.  In HSA, the code you write will be
executed by multiple threads at once (often hundreds or thousands).  Your
solution will be modelled by defining a thread hierarchy of <em>grid</em>, <em>workgroup</em>
and <em>workitem</em>.</p>
<p>Numba’s HSA support exposes facilities to declare and manage this
hierarchy of threads.</p>
</div>
<div class="section" id="introduction-for-cuda-programmers">
<h2>5.2.2. Introduction for CUDA Programmers<a class="headerlink" href="#introduction-for-cuda-programmers" title="Permalink to this headline">¶</a></h2>
<p>HSA execution model is similar to CUDA. The memory model employed by HSA on ROC
GPUs is also similar to that of CUDA. ROC GPUs have dedicated on GPU memory,
therefore the <code class="docutils literal notranslate"><span class="pre">to_device()</span></code> and <code class="docutils literal notranslate"><span class="pre">copy_to_host()</span></code> etc. are required as per
CUDA.</p>
<p>Here’s a quick mapping of the CUDA terms to HSA:</p>
<ul class="simple">
<li><p>A <code class="docutils literal notranslate"><span class="pre">workitem</span></code> is equivalent to a CUDA thread.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">workgroup</span></code> is equivalent to a CUDA thread block.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">grid</span></code> is equivalent to a CUDA grid.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">wavefront</span></code> is equivalent to a CUDA <code class="docutils literal notranslate"><span class="pre">warp</span></code>.</p></li>
</ul>
</div>
<div class="section" id="kernel-declaration">
<h2>5.2.3. Kernel declaration<a class="headerlink" href="#kernel-declaration" title="Permalink to this headline">¶</a></h2>
<p>A <em>kernel function</em> is a GPU function that is meant to be called from CPU
code.  It gives it two fundamental characteristics:</p>
<ul class="simple">
<li><p>kernels cannot explicitly return a value; all result data must be written
to an array passed to the function (if computing a scalar, you will
probably pass a one-element array);</p></li>
<li><p>kernels explicitly declare their thread hierarchy when called: i.e.
the number of workgroups and the number of workitems per workgroup
(note that while a kernel is compiled once, it can be called multiple
times with different workgroup sizes or grid sizes).</p></li>
</ul>
<p>At first sight, writing a HSA kernel with Numba looks very much like
writing a <a class="reference internal" href="../glossary.html#term-jit-function"><span class="xref std std-term">JIT function</span></a> for the CPU:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@roc</span><span class="o">.</span><span class="n">jit</span>
<span class="k">def</span> <span class="nf">increment_by_one</span><span class="p">(</span><span class="n">an_array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Increment all array elements by one.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># code elided here; read further for different implementations</span>
</pre></div>
</div>
</div>
<div class="section" id="kernel-invocation">
<span id="hsa-kernel-invocation"></span><h2>5.2.4. Kernel invocation<a class="headerlink" href="#kernel-invocation" title="Permalink to this headline">¶</a></h2>
<p>A kernel is typically launched in the following way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">itempergroup</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">groupperrange</span> <span class="o">=</span> <span class="p">(</span><span class="n">an_array</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="p">(</span><span class="n">itempergroup</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="n">itempergroup</span>
<span class="n">increment_by_one</span><span class="p">[</span><span class="n">groupperrange</span><span class="p">,</span> <span class="n">itempergroup</span><span class="p">](</span><span class="n">an_array</span><span class="p">)</span>
</pre></div>
</div>
<p>We notice two steps here:</p>
<ul class="simple">
<li><p>Instantiate the kernel proper, by specifying a number of workgroup
(or “workgroup per grid”), and a number of workitems per workgroup.  The
product of the two will give the total number of workitem launched.  Kernel
instantiation is done by taking the compiled kernel function
(here <code class="docutils literal notranslate"><span class="pre">increment_by_one</span></code>) and indexing it with a tuple of integers.</p></li>
<li><p>Running the kernel, by passing it the input array (and any separate
output arrays if necessary).  By default, running a kernel is synchronous:
the function returns when the kernel has finished executing and the
data is synchronized back.</p></li>
</ul>
<div class="section" id="choosing-the-workgroup-size">
<h3>5.2.4.1. Choosing the workgroup size<a class="headerlink" href="#choosing-the-workgroup-size" title="Permalink to this headline">¶</a></h3>
<p>It might seem curious to have a two-level hierarchy when declaring the
number of workitem needed by a kernel.  The workgroup size (i.e. number of
workitem per workgroup) is often crucial:</p>
<ul class="simple">
<li><p>On the software side, the workgroup size determines how many threads
share a given area of <a class="reference internal" href="memory.html#roc-shared-memory"><span class="std std-ref">shared memory</span></a>.</p></li>
<li><dl class="simple">
<dt>On the hardware side, the workgroup size must be large enough for full</dt><dd><p>occupation of execution units.</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="multi-dimensional-workgroup-and-grid">
<h3>5.2.4.2. Multi-dimensional workgroup and grid<a class="headerlink" href="#multi-dimensional-workgroup-and-grid" title="Permalink to this headline">¶</a></h3>
<p>To help deal with multi-dimensional arrays, HSA allows you to specify
multi-dimensional workgroups and grids.  In the example above, you could
make <code class="docutils literal notranslate"><span class="pre">itempergroup</span></code> and <code class="docutils literal notranslate"><span class="pre">groupperrange</span></code> tuples of one, two
or three integers.  Compared to 1D declarations of equivalent sizes,
this doesn’t change anything to the efficiency or behaviour of generated
code, but can help you write your algorithms in a more natural way.</p>
</div>
</div>
<div class="section" id="workitem-positioning">
<h2>5.2.5. WorkItem positioning<a class="headerlink" href="#workitem-positioning" title="Permalink to this headline">¶</a></h2>
<p>When running a kernel, the kernel function’s code is executed by every
thread once.  It therefore has to know which thread it is in, in order
to know which array element(s) it is responsible for (complex algorithms
may define more complex responsibilities, but the underlying principle
is the same).</p>
<p>One way is for the thread to determines its position in the grid and
workgroup and manually compute the corresponding array position:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@roc</span><span class="o">.</span><span class="n">jit</span>
<span class="k">def</span> <span class="nf">increment_by_one</span><span class="p">(</span><span class="n">an_array</span><span class="p">):</span>
    <span class="c1"># workitem id in a 1D workgroup</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="n">roc</span><span class="o">.</span><span class="n">get_local_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># workgroup id in a 1D grid</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="n">roc</span><span class="o">.</span><span class="n">get_group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># workgroup size, i.e. number of workitem per workgroup</span>
    <span class="n">bw</span> <span class="o">=</span> <span class="n">roc</span><span class="o">.</span><span class="n">get_local_size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Compute flattened index inside the array</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">tx</span> <span class="o">+</span> <span class="n">ty</span> <span class="o">*</span> <span class="n">bw</span>
    <span class="c1"># The above is equivalent to pos = roc.get_global_id(0)</span>
    <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">an_array</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>  <span class="c1"># Check array boundaries</span>
        <span class="n">an_array</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unless you are sure the workgroup size and grid size is a divisor
of your array size, you <strong>must</strong> check boundaries as shown above.</p>
</div>
<p><a class="reference internal" href="#numba.roc.get_local_id" title="numba.roc.get_local_id"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_local_id()</span></code></a>, <a class="reference internal" href="#numba.roc.get_local_size" title="numba.roc.get_local_size"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_local_size()</span></code></a>, <a class="reference internal" href="#numba.roc.get_group_id" title="numba.roc.get_group_id"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_group_id()</span></code></a> and
<a class="reference internal" href="#numba.roc.get_global_id" title="numba.roc.get_global_id"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_global_id()</span></code></a> are special functions provided by the HSA backend for
the sole purpose of knowing the geometry of the thread hierarchy and the
position of the current workitem within that geometry.</p>
<dl class="function">
<dt id="numba.roc.get_local_id">
<code class="sig-prename descclassname">numba.roc.</code><code class="sig-name descname">get_local_id</code><span class="sig-paren">(</span><em class="sig-param">dim</em><span class="sig-paren">)</span><a class="headerlink" href="#numba.roc.get_local_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the index of the dimension being queried</p>
<p>Returns local workitem ID in the the current workgroup for the given
dimension. For 1D workgroup, the index is an integer spanning the range
from 0 inclusive to <a class="reference internal" href="#numba.roc.get_local_size" title="numba.roc.get_local_size"><code class="xref py py-func docutils literal notranslate"><span class="pre">numba.roc.get_local_size()</span></code></a> exclusive.</p>
</dd></dl>

<dl class="function">
<dt id="numba.roc.get_local_size">
<code class="sig-prename descclassname">numba.roc.</code><code class="sig-name descname">get_local_size</code><span class="sig-paren">(</span><em class="sig-param">dim</em><span class="sig-paren">)</span><a class="headerlink" href="#numba.roc.get_local_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the index of the dimension being queried</p>
<p>Returns the size of the workgroup at the given dimension.
The value is declared when instantiating the kernel.
This value is the same for all workitems in a given kernel,
even if they belong to different workgroups (i.e. each workgroups is “full”).</p>
</dd></dl>

<dl class="function">
<dt id="numba.roc.get_group_id">
<code class="sig-prename descclassname">numba.roc.</code><code class="sig-name descname">get_group_id</code><span class="sig-paren">(</span><em class="sig-param">dim</em><span class="sig-paren">)</span><a class="headerlink" href="#numba.roc.get_group_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the index of the dimension being queried</p>
<p>Returns the workgroup ID in the grid of workgroup launched a kernel.</p>
</dd></dl>

<dl class="function">
<dt id="numba.roc.get_global_id">
<code class="sig-prename descclassname">numba.roc.</code><code class="sig-name descname">get_global_id</code><span class="sig-paren">(</span><em class="sig-param">dim</em><span class="sig-paren">)</span><a class="headerlink" href="#numba.roc.get_global_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the index of the dimension being queried</p>
<p>Returns the global workitem ID for the given dimension.  Unlike <cite>numba.roc
.get_local_id()</cite>, this number is unique for all workitems in a grid.</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="memory.html" class="btn btn-neutral float-right" title="5.3. Memory management" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="overview.html" class="btn btn-neutral float-left" title="5.1. Overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2012-2020, Anaconda, Inc. and others

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>