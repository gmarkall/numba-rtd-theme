

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>8.1.1. NBEP 1: Changes in integer typing &mdash; Numba 0.49.0dev0+637.g3a659b257 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/numba-blue-icon-rgb.svg"/>
  
  
  
    <link rel="canonical" href="http://numba.pydata.org/numba-doc/latest/index.htmlproposals/integer-typing.html"/>
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="8.2.1. NBEP 2: Extension points" href="extension-points.html" />
    <link rel="prev" title="8. Numba Enhancement Proposals" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #00A3E0" >
          

          
            <a href="../index.html" class="icon icon-home"> Numba
          

          
            
            <img src="../_static/numba-white-icon-rgb.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.49
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">1. User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">2. Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cuda/index.html">3. Numba for CUDA GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cuda-reference/index.html">4. CUDA Python Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../roc/index.html">5. Numba for AMD ROC GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extending/index.html">6. Extending Numba</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer/index.html">7. Developer Manual</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">8. Numba Enhancement Proposals</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#implemented-proposals">8.1. Implemented proposals</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">8.1.1. NBEP 1: Changes in integer typing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#current-semantics">8.1.1.1. Current semantics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#proposal-predictable-width-conserving-typing">8.1.1.2. Proposal: predictable width-conserving typing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#proposal-impact">8.1.1.3. Proposal impact</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#other-proposals">8.2. Other proposals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">9. Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">10. Release Notes</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Numba</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">8. Numba Enhancement Proposals</a> &raquo;</li>
        
      <li>8.1.1. NBEP 1: Changes in integer typing</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/proposals/integer-typing.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="nbep-1-changes-in-integer-typing">
<span id="nbep-1"></span><h1>8.1.1. NBEP 1: Changes in integer typing<a class="headerlink" href="#nbep-1-changes-in-integer-typing" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Antoine Pitrou</p>
</dd>
<dt class="field-even">Date</dt>
<dd class="field-even"><p>July 2015</p>
</dd>
<dt class="field-odd">Status</dt>
<dd class="field-odd"><p>Final</p>
</dd>
</dl>
<div class="section" id="current-semantics">
<h2>8.1.1.1. Current semantics<a class="headerlink" href="#current-semantics" title="Permalink to this headline">¶</a></h2>
<p>Type inference of integers in Numba currently has some subtleties
and some corner cases.  The simple case is when some variable has an obvious
Numba type (for example because it is the result of a constructor call to a
Numpy scalar type such as <code class="docutils literal notranslate"><span class="pre">np.int64</span></code>). That case suffers no ambiguity.</p>
<p>The less simple case is when a variable doesn’t bear such explicit
information.  This can happen because it is inferred from a built-in Python
<code class="docutils literal notranslate"><span class="pre">int</span></code> value, or from an arithmetic operation between two integers, or
other cases yet.  Then Numba has a number of rules to infer the resulting
Numba type, especially its signedness and bitwidth.</p>
<p>Currently, the generic case could be summarized as: <em>start small,
grow bigger as required</em>.  Concretely:</p>
<ol class="arabic simple">
<li><p>Each constant or pseudo-constant is inferred using the <em>smallest signed
integer type</em> that can correctly represent it (or, possibly, <code class="docutils literal notranslate"><span class="pre">uint64</span></code>
for positive integers between <code class="docutils literal notranslate"><span class="pre">2**63</span></code> and <code class="docutils literal notranslate"><span class="pre">2**64</span> <span class="pre">-</span> <span class="pre">1</span></code>).</p></li>
<li><p>The result of an operation is typed so as to ensure safe representation
in the face of overflow and other magnitude increases (for example,
<code class="docutils literal notranslate"><span class="pre">int32</span> <span class="pre">+</span> <span class="pre">int32</span></code> would be typed <code class="docutils literal notranslate"><span class="pre">int64</span></code>).</p></li>
<li><p>As an exception, a Python <code class="docutils literal notranslate"><span class="pre">int</span></code> used as function argument is always
typed <code class="docutils literal notranslate"><span class="pre">intp</span></code>, a pointer-size integer.  This is to avoid the proliferation
of compiled specializations, as otherwise various integer bitwidths
in input arguments may produce multiple signatures.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The second rule above (the “respect magnitude increases” rule)
reproduces Numpy’s behaviour with arithmetic on scalar values.
Numba, however, has different implementation and performance constraints
than Numpy scalars.</p>
<p>It is worth nothing, by the way, that Numpy arrays do not implement
said rule (i.e. <code class="docutils literal notranslate"><span class="pre">array(int32)</span> <span class="pre">+</span> <span class="pre">array(int32)</span></code> is typed <code class="docutils literal notranslate"><span class="pre">array(int32)</span></code>,
not <code class="docutils literal notranslate"><span class="pre">array(int64)</span></code>).  Probably because this makes performance more
controllable.</p>
</div>
<p>This has several non-obvious side-effects:</p>
<ol class="arabic">
<li><p>It is difficult to predict the precise type of a value inside a function,
after several operations.  The basic operands in an expression tree
may for example be <code class="docutils literal notranslate"><span class="pre">int8</span></code> but the end result may be <code class="docutils literal notranslate"><span class="pre">int64</span></code>.  Whether
this is desirable or not is an open question; it is good for correctness,
but potentially bad for performance.</p></li>
<li><p>In trying to follow the correctness over predictability rule, some values
can actually leave the integer realm.  For example, <code class="docutils literal notranslate"><span class="pre">int64</span> <span class="pre">+</span> <span class="pre">uint64</span></code>
is typed <code class="docutils literal notranslate"><span class="pre">float64</span></code> in order to avoid magnitude losses (but incidentally
will lose precision on large integer values…), again following Numpy’s
semantics for scalars.  This is usually not intended by the user.</p></li>
<li><p>More complicated scenarios can produce unexpected errors at the type unification
stage.  An example is at <a class="reference external" href="https://github.com/numba/numba/issues/1299">Github issue 1299</a>,
the gist of which is reproduced here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="n">variable</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">variable</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
</pre></div>
</div>
<p>At the time of this writing, this fails compiling, on a 64-bit system,
with the error:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>numba.errors.TypingError: Failed at nopython (nopython frontend)
Can&#39;t unify types of variable &#39;$48.4&#39;: $48.4 := {array(int32, 1d, C), array(int64, 1d, C)}
</pre></div>
</div>
<p>People expert with Numba’s type unification system can understand why.
But the user is caught in mystery.</p>
</li>
</ol>
</div>
<div class="section" id="proposal-predictable-width-conserving-typing">
<h2>8.1.1.2. Proposal: predictable width-conserving typing<a class="headerlink" href="#proposal-predictable-width-conserving-typing" title="Permalink to this headline">¶</a></h2>
<p>We propose to turn the current typing philosophy on its head.  Instead
of “<em>start small and grow as required</em>”, we propose “<em>start big and keep
the width unchanged</em>”.</p>
<p>Concretely:</p>
<ol class="arabic simple">
<li><p>The typing of Python <code class="docutils literal notranslate"><span class="pre">int</span></code> values used as function arguments doesn’t
change, as it works satisfyingly and doesn’t surprise the user.</p></li>
<li><p>The typing of integer <em>constants</em> (and pseudo-constants) changes to match
the typing of integer arguments.  That is, every non-explicitly typed
integer constant is typed <code class="docutils literal notranslate"><span class="pre">intp</span></code>, the pointer-sized integer; except for
the rare cases where <code class="docutils literal notranslate"><span class="pre">int64</span></code> (on 32-bit systems) or <code class="docutils literal notranslate"><span class="pre">uint64</span></code> is
required.</p></li>
<li><p>Operations on integers promote bitwidth to <code class="docutils literal notranslate"><span class="pre">intp</span></code>, if smaller, otherwise
they don’t promote.  For example, on a 32-bit machine, <code class="docutils literal notranslate"><span class="pre">int8</span> <span class="pre">+</span> <span class="pre">int8</span></code>
is typed <code class="docutils literal notranslate"><span class="pre">int32</span></code>, as is <code class="docutils literal notranslate"><span class="pre">int32</span> <span class="pre">+</span> <span class="pre">int32</span></code>.  However, <code class="docutils literal notranslate"><span class="pre">int64</span> <span class="pre">+</span> <span class="pre">int64</span></code>
is typed <code class="docutils literal notranslate"><span class="pre">int64</span></code>.</p></li>
<li><p>Furthermore, mixed operations between signed and unsigned fall back to
signed, while following the same bitwidth rule.  For example, on a
32-bit machine, <code class="docutils literal notranslate"><span class="pre">int8</span> <span class="pre">+</span> <span class="pre">uint16</span></code> is typed <code class="docutils literal notranslate"><span class="pre">int32</span></code>, as is
<code class="docutils literal notranslate"><span class="pre">uint32</span> <span class="pre">+</span> <span class="pre">int32</span></code>.</p></li>
</ol>
</div>
<div class="section" id="proposal-impact">
<h2>8.1.1.3. Proposal impact<a class="headerlink" href="#proposal-impact" title="Permalink to this headline">¶</a></h2>
<div class="section" id="semantics">
<h3>8.1.1.3.1. Semantics<a class="headerlink" href="#semantics" title="Permalink to this headline">¶</a></h3>
<p>With this proposal, the semantics become clearer.  Regardless of whether
the arguments and constants of a function were explicitly typed or not,
the results of various expressions at any point in the function have
easily predictable types.</p>
<p>When using built-in Python <code class="docutils literal notranslate"><span class="pre">int</span></code>, the user gets acceptable magnitude
(32 or 64 bits depending on the system’s bitness), and the type remains
the same across all computations.</p>
<p>When explicitly using smaller bitwidths, intermediate results don’t
suffer from magnitude loss, since their bitwidth is promoted to <code class="docutils literal notranslate"><span class="pre">intp</span></code>.</p>
<p>There is also less potential for annoyances with the type unification
system as demonstrated above.  The user would have to force several
different types to be faced with such an error.</p>
<p>One potential cause for concern is the discrepancy with Numpy’s scalar
semantics; but at the same time this brings Numba scalar semantics closer
to array semantics (both Numba’s and Numpy’s), which seems a desirable
outcome as well.</p>
<p>It is worth pointing out that some sources of integer numbers, such
as the <code class="docutils literal notranslate"><span class="pre">range()</span></code> built-in, always yield 32-bit integers or larger.
This proposal could be an opportunity to standardize them on <code class="docutils literal notranslate"><span class="pre">intp</span></code>.</p>
</div>
<div class="section" id="performance">
<h3>8.1.1.3.2. Performance<a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h3>
<p>Except in trivial cases, it seems unlikely that the current “best fit”
behaviour for integer constants really brings a performance benefit.  After
all, most integers in Numba code would either be stored in arrays (with
well-known types, chosen by the user) or be used as indices, where a <code class="docutils literal notranslate"><span class="pre">int8</span></code>
is highly unlikely to fare better than a <code class="docutils literal notranslate"><span class="pre">intp</span></code> (actually, it may be worse,
if LLVM isn’t able to optimize away the required sign-extension).</p>
<p>As a side note, the default use of <code class="docutils literal notranslate"><span class="pre">intp</span></code> rather than <code class="docutils literal notranslate"><span class="pre">int64</span></code>
ensures that 32-bit systems won’t suffer from poor arithmetic performance.</p>
</div>
<div class="section" id="implementation">
<h3>8.1.1.3.3. Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h3>
<p>Optimistically, this proposal may simplify some Numba internals a bit.
Or, at least, it doesn’t threaten to make them significantly more complicated.</p>
</div>
<div class="section" id="limitations">
<h3>8.1.1.3.4. Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h3>
<p>This proposal doesn’t really solve the combination of signed and unsigned
integers.  It is geared mostly at solving the bitwidth issues, which are
a somewhat common cause of pain for users.  Unsigned integers are in
practice very uncommon in Numba-compiled code, except when explicitly
asked for, and therefore much less of a pain point.</p>
<p>On the bitwidth front, 32-bit systems could still show discrepancies based
on the values of constants: if a constant is too large to fit in 32 bits,
it is typed <code class="docutils literal notranslate"><span class="pre">int64</span></code>, which propagates through other computations.
This would be a reminiscence of the current behaviour, but rarer and much
more controlled still.</p>
</div>
<div class="section" id="long-term-horizon">
<h3>8.1.1.3.5. Long-term horizon<a class="headerlink" href="#long-term-horizon" title="Permalink to this headline">¶</a></h3>
<p>While we believe this proposal makes Numba’s behaviour more regular and more
predictable, it also pulls it further from general compatibility with pure
Python semantics, where users can assume arbitrary-precision integers without
any truncation issues.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="extension-points.html" class="btn btn-neutral float-right" title="8.2.1. NBEP 2: Extension points" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="8. Numba Enhancement Proposals" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2012-2020, Anaconda, Inc. and others

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>