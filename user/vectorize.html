

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>1.6. Creating Numpy universal functions &mdash; Numba 0.49.0dev0+636.ga4807f5d8 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/numba-blue-icon-rgb.svg"/>
  
  
  
    <link rel="canonical" href="http://numba.pydata.org/numba-doc/latest/index.htmluser/vectorize.html"/>
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="1.7. Compiling Python classes with @jitclass" href="jitclass.html" />
    <link rel="prev" title="1.5. Flexible specializations with @generated_jit" href="generated-jit.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Numba
          

          
            
            <img src="../_static/numba-blue-icon-rgb.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.49
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">1. User Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="5minguide.html">1.1. A ~5 minute guide to Numba</a></li>
<li class="toctree-l2"><a class="reference internal" href="overview.html">1.2. Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="installing.html">1.3. Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="jit.html">1.4. Compiling Python code with <code class="docutils literal notranslate"><span class="pre">&#64;jit</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="generated-jit.html">1.5. Flexible specializations with <code class="docutils literal notranslate"><span class="pre">&#64;generated_jit</span></code></a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">1.6. Creating Numpy universal functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-vectorize-decorator">1.6.1. The <code class="docutils literal notranslate"><span class="pre">&#64;vectorize</span></code> decorator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-guvectorize-decorator">1.6.2. The <code class="docutils literal notranslate"><span class="pre">&#64;guvectorize</span></code> decorator</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overwriting-input-values">1.6.2.1. Overwriting input values</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dynamic-universal-functions">1.6.3. Dynamic universal functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="jitclass.html">1.7. Compiling Python classes with <code class="docutils literal notranslate"><span class="pre">&#64;jitclass</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="cfunc.html">1.8. Creating C callbacks with <code class="docutils literal notranslate"><span class="pre">&#64;cfunc</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pycc.html">1.9. Compiling code ahead of time</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html">1.10. Automatic parallelization with <code class="docutils literal notranslate"><span class="pre">&#64;jit</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="stencil.html">1.11. Using the <code class="docutils literal notranslate"><span class="pre">&#64;stencil</span></code> decorator</a></li>
<li class="toctree-l2"><a class="reference internal" href="withobjmode.html">1.12. Callback into the Python Interpreter from within JIT’ed code</a></li>
<li class="toctree-l2"><a class="reference internal" href="jit-module.html">1.13. Automatic module jitting with <code class="docutils literal notranslate"><span class="pre">jit_module</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html">1.14. Performance Tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="threading-layer.html">1.15. The Threading Layers</a></li>
<li class="toctree-l2"><a class="reference internal" href="cli.html">1.16. Command line interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="troubleshoot.html">1.17. Troubleshooting and tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html">1.18. Frequently Asked Questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html">1.19. Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="talks.html">1.20. Talks and Tutorials</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">2. Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cuda/index.html">3. Numba for CUDA GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cuda-reference/index.html">4. CUDA Python Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../roc/index.html">5. Numba for AMD ROC GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extending/index.html">6. Extending Numba</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer/index.html">7. Developer Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proposals/index.html">8. Numba Enhancement Proposals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">9. Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">10. Release Notes</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Numba</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">1. User Manual</a> &raquo;</li>
        
      <li>1.6. Creating Numpy universal functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/user/vectorize.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="creating-numpy-universal-functions">
<h1>1.6. Creating Numpy universal functions<a class="headerlink" href="#creating-numpy-universal-functions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-vectorize-decorator">
<span id="vectorize"></span><h2>1.6.1. The <code class="docutils literal notranslate"><span class="pre">&#64;vectorize</span></code> decorator<a class="headerlink" href="#the-vectorize-decorator" title="Permalink to this headline">¶</a></h2>
<p>Numba’s vectorize allows Python functions taking scalar input arguments to
be used as NumPy <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html">ufuncs</a>.  Creating a traditional NumPy ufunc is
not the most straightforward process and involves writing some C code.
Numba makes this easy.  Using the <a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal notranslate"><span class="pre">vectorize()</span></code></a> decorator, Numba
can compile a pure Python function into a ufunc that operates over NumPy
arrays as fast as traditional ufuncs written in C.</p>
<p>Using <a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal notranslate"><span class="pre">vectorize()</span></code></a>, you write your function as operating over
input scalars, rather than arrays.  Numba will generate the surrounding
loop (or <em>kernel</em>) allowing efficient iteration over the actual inputs.</p>
<p>The <a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal notranslate"><span class="pre">vectorize()</span></code></a> decorator has two modes of operation:</p>
<ul class="simple">
<li><p>Eager, or decoration-time, compilation: If you pass one or more type
signatures to the decorator, you will be building a Numpy universal
function (ufunc).  The rest of this subsection describes building
ufuncs using decoration-time compilation.</p></li>
<li><p>Lazy, or call-time, compilation: When not given any signatures, the
decorator will give you a Numba dynamic universal function
(<a class="reference internal" href="../reference/jit-compilation.html#numba.DUFunc" title="numba.DUFunc"><code class="xref py py-class docutils literal notranslate"><span class="pre">DUFunc</span></code></a>) that dynamically compiles a new kernel when
called with a previously unsupported input type.  A later
subsection, “<a class="reference internal" href="#dynamic-universal-functions"><span class="std std-ref">Dynamic universal functions</span></a>”, describes this mode in
more depth.</p></li>
</ul>
<p>As described above, if you pass a list of signatures to the
<a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal notranslate"><span class="pre">vectorize()</span></code></a> decorator, your function will be compiled
into a Numpy ufunc.  In the basic case, only one signature will be
passed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">vectorize</span><span class="p">,</span> <span class="n">float64</span>

<span class="nd">@vectorize</span><span class="p">([</span><span class="n">float64</span><span class="p">(</span><span class="n">float64</span><span class="p">,</span> <span class="n">float64</span><span class="p">)])</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>If you pass several signatures, beware that you have to pass most specific
signatures before least specific ones (e.g., single-precision floats
before double-precision floats), otherwise type-based dispatching will not work
as expected:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@vectorize</span><span class="p">([</span><span class="n">int32</span><span class="p">(</span><span class="n">int32</span><span class="p">,</span> <span class="n">int32</span><span class="p">),</span>
            <span class="n">int64</span><span class="p">(</span><span class="n">int64</span><span class="p">,</span> <span class="n">int64</span><span class="p">),</span>
            <span class="n">float32</span><span class="p">(</span><span class="n">float32</span><span class="p">,</span> <span class="n">float32</span><span class="p">),</span>
            <span class="n">float64</span><span class="p">(</span><span class="n">float64</span><span class="p">,</span> <span class="n">float64</span><span class="p">)])</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>The function will work as expected over the specified array types:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">array([ 0,  2,  4,  6,  8, 10])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">array([ 0. ,  0.4,  0.8,  1.2,  1.6,  2. ])</span>
</pre></div>
</div>
<p>but it will fail working on other types:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">ufunc &#39;ufunc&#39; not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule &#39;&#39;safe&#39;&#39;</span>
</pre></div>
</div>
<p>You might ask yourself, “why would I go through this instead of compiling
a simple iteration loop using the <a class="reference internal" href="jit.html#jit"><span class="std std-ref">&#64;jit</span></a> decorator?”.  The
answer is that NumPy ufuncs automatically get other features such as
reduction, accumulation or broadcasting.  Using the example above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([12, 15, 18, 21])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 6, 22, 38])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  6,  8, 10],</span>
<span class="go">       [12, 15, 18, 21]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 0,  1,  3,  6],</span>
<span class="go">       [ 4,  9, 15, 22],</span>
<span class="go">       [ 8, 17, 27, 38]])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html#ufunc">Standard features of ufuncs</a> (NumPy documentation).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only the broadcasting features of ufuncs are supported in compiled code.</p>
</div>
<p>The <a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal notranslate"><span class="pre">vectorize()</span></code></a> decorator supports multiple ufunc targets:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Target</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>cpu</p></td>
<td><p>Single-threaded CPU</p></td>
</tr>
<tr class="row-odd"><td><p>parallel</p></td>
<td><p>Multi-core CPU</p></td>
</tr>
<tr class="row-even"><td><p>cuda</p></td>
<td><p>CUDA GPU</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This creates an <em>ufunc-like</em> object.
See <a class="reference external" href="../cuda/ufunc.html">documentation for CUDA ufunc</a> for detail.</p>
</div>
</td>
</tr>
</tbody>
</table>
<p>A general guideline is to choose different targets for different data sizes
and algorithms.
The “cpu” target works well for small data sizes (approx. less than 1KB) and low
compute intensity algorithms. It has the least amount of overhead.
The “parallel” target works well for medium data sizes (approx. less than 1MB).
Threading adds a small delay.
The “cuda” target works well for big data sizes (approx. greater than 1MB) and
high compute intensity algorithms.  Transferring memory to and from the GPU adds
significant overhead.</p>
</div>
<div class="section" id="the-guvectorize-decorator">
<span id="guvectorize"></span><h2>1.6.2. The <code class="docutils literal notranslate"><span class="pre">&#64;guvectorize</span></code> decorator<a class="headerlink" href="#the-guvectorize-decorator" title="Permalink to this headline">¶</a></h2>
<p>While <a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal notranslate"><span class="pre">vectorize()</span></code></a> allows you to write ufuncs that work on one
element at a time, the <a class="reference internal" href="../reference/jit-compilation.html#numba.guvectorize" title="numba.guvectorize"><code class="xref py py-func docutils literal notranslate"><span class="pre">guvectorize()</span></code></a> decorator takes the concept
one step further and allows you to write ufuncs that will work on an
arbitrary number of elements of input arrays, and take and return arrays of
differing dimensions.  The typical example is a running median or a
convolution filter.</p>
<p>Contrary to <a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal notranslate"><span class="pre">vectorize()</span></code></a> functions, <a class="reference internal" href="../reference/jit-compilation.html#numba.guvectorize" title="numba.guvectorize"><code class="xref py py-func docutils literal notranslate"><span class="pre">guvectorize()</span></code></a>
functions don’t return their result value: they take it as an array
argument, which must be filled in by the function.  This is because the
array is actually allocated by NumPy’s dispatch mechanism, which calls into
the Numba-generated code.</p>
<p>Here is a very simple example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@guvectorize</span><span class="p">([(</span><span class="n">int64</span><span class="p">[:],</span> <span class="n">int64</span><span class="p">,</span> <span class="n">int64</span><span class="p">[:])],</span> <span class="s1">&#39;(n),()-&gt;(n)&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>The underlying Python function simply adds a given scalar (<code class="docutils literal notranslate"><span class="pre">y</span></code>) to all
elements of a 1-dimension array.  What’s more interesting is the declaration.
There are two things there:</p>
<ul class="simple">
<li><p>the declaration of input and output <em>layouts</em>, in symbolic form:
<code class="docutils literal notranslate"><span class="pre">(n),()-&gt;(n)</span></code> tells NumPy that the function takes a <em>n</em>-element one-dimension
array, a scalar (symbolically denoted by the empty tuple <code class="docutils literal notranslate"><span class="pre">()</span></code>) and
returns a <em>n</em>-element one-dimension array;</p></li>
<li><p>the list of supported concrete <em>signatures</em> as per <code class="docutils literal notranslate"><span class="pre">&#64;vectorize</span></code>; here,
as in the above example, we demonstrate <code class="docutils literal notranslate"><span class="pre">int64</span></code> arrays.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>1D array type can also receive scalar arguments (those with shape <code class="docutils literal notranslate"><span class="pre">()</span></code>).
In the above example, the second argument also could be declared as
<code class="docutils literal notranslate"><span class="pre">int64[:]</span></code>.  In that case, the value must be read by <code class="docutils literal notranslate"><span class="pre">y[0]</span></code>.</p>
</div>
<p>We can now check what the compiled ufunc does, over a simple example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([2, 3, 4, 5, 6])</span>
</pre></div>
</div>
<p>The nice thing is that NumPy will automatically dispatch over more
complicated inputs, depending on their shapes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">array([[10, 11, 12],</span>
<span class="go">       [13, 14, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]))</span>
<span class="go">array([[10, 11, 12],</span>
<span class="go">       [23, 24, 25]])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Both <a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal notranslate"><span class="pre">vectorize()</span></code></a> and <a class="reference internal" href="../reference/jit-compilation.html#numba.guvectorize" title="numba.guvectorize"><code class="xref py py-func docutils literal notranslate"><span class="pre">guvectorize()</span></code></a> support
passing <code class="docutils literal notranslate"><span class="pre">nopython=True</span></code> <a class="reference internal" href="jit.html#jit-nopython"><span class="std std-ref">as in the &#64;jit decorator</span></a>.
Use it to ensure the generated code does not fallback to
<a class="reference internal" href="../glossary.html#term-object-mode"><span class="xref std std-term">object mode</span></a>.</p>
</div>
<div class="section" id="overwriting-input-values">
<span id="id1"></span><h3>1.6.2.1. Overwriting input values<a class="headerlink" href="#overwriting-input-values" title="Permalink to this headline">¶</a></h3>
<p>In most cases, writing to inputs may also appear to work - however, this
behaviour cannot be relied on. Consider the following example function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@guvectorize</span><span class="p">([(</span><span class="n">float64</span><span class="p">[:],</span> <span class="n">float64</span><span class="p">[:])],</span> <span class="s1">&#39;()-&gt;()&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">init_values</span><span class="p">(</span><span class="n">invals</span><span class="p">,</span> <span class="n">outvals</span><span class="p">):</span>
    <span class="n">invals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">6.5</span>
    <span class="n">outvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.2</span>
</pre></div>
</div>
<p>Calling the <cite>init_values</cite> function with an array of <cite>float64</cite> type results in
visible changes to the input:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">invals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outvals</span> <span class="o">=</span> <span class="n">init_values</span><span class="p">(</span><span class="n">invals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invals</span>
<span class="go">array([[6.5, 6.5, 6.5],</span>
<span class="go">       [6.5, 6.5, 6.5],</span>
<span class="go">       [6.5, 6.5, 6.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outvals</span>
<span class="go">array([[4.2, 4.2, 4.2],</span>
<span class="go">    [4.2, 4.2, 4.2],</span>
<span class="go">    [4.2, 4.2, 4.2]])</span>
</pre></div>
</div>
<p>This works because NumPy can pass the input data directly into the <cite>init_values</cite>
function as the data <cite>dtype</cite> matches that of the declared argument.  However, it
may also create and pass in a temporary array, in which case changes to the
input are lost. For example, this can occur when casting is required. To
demonstrate, we can  use an array of <cite>float32</cite> with the <cite>init_values</cite> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">invals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outvals</span> <span class="o">=</span> <span class="n">init_values</span><span class="p">(</span><span class="n">invals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invals</span>
<span class="go">array([[0., 0., 0.],</span>
<span class="go">       [0., 0., 0.],</span>
<span class="go">       [0., 0., 0.]], dtype=float32)</span>
</pre></div>
</div>
<p>In this case, there is no change to the <cite>invals</cite> array because the temporary
casted array was mutated instead.</p>
</div>
</div>
<div class="section" id="dynamic-universal-functions">
<span id="id2"></span><h2>1.6.3. Dynamic universal functions<a class="headerlink" href="#dynamic-universal-functions" title="Permalink to this headline">¶</a></h2>
<p>As described above, if you do not pass any signatures to the
<a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal notranslate"><span class="pre">vectorize()</span></code></a> decorator, your Python function will be used
to build a dynamic universal function, or <a class="reference internal" href="../reference/jit-compilation.html#numba.DUFunc" title="numba.DUFunc"><code class="xref py py-class docutils literal notranslate"><span class="pre">DUFunc</span></code></a>.  For
example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">vectorize</span>

<span class="nd">@vectorize</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
</pre></div>
</div>
<p>The resulting <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code> is a <a class="reference internal" href="../reference/jit-compilation.html#numba.DUFunc" title="numba.DUFunc"><code class="xref py py-class docutils literal notranslate"><span class="pre">DUFunc</span></code></a> instance that
starts with no supported input types.  As you make calls to <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code>,
Numba generates new kernels whenever you pass a previously unsupported
input type.  Given the example above, the following set of interpreter
interactions illustrate how dynamic compilation works:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span>
<span class="go">&lt;numba._DUFunc &#39;f&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">ufunc</span>
<span class="go">&lt;ufunc &#39;f&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">ufunc</span><span class="o">.</span><span class="n">types</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>The example above shows that <a class="reference internal" href="../reference/jit-compilation.html#numba.DUFunc" title="numba.DUFunc"><code class="xref py py-class docutils literal notranslate"><span class="pre">DUFunc</span></code></a> instances are not
ufuncs.  Rather than subclass ufunc’s, <a class="reference internal" href="../reference/jit-compilation.html#numba.DUFunc" title="numba.DUFunc"><code class="xref py py-class docutils literal notranslate"><span class="pre">DUFunc</span></code></a>
instances work by keeping a <a class="reference internal" href="../reference/jit-compilation.html#numba.DUFunc.ufunc" title="numba.DUFunc.ufunc"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ufunc</span></code></a> member, and
then delegating ufunc property reads and method calls to this member
(also known as type aggregation).  When we look at the initial types
supported by the ufunc, we can verify there are none.</p>
<p>Let’s try to make a call to <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">types</span>   <span class="c1"># shorthand for f.ufunc.types</span>
<span class="go">[&#39;ll-&gt;l&#39;]</span>
</pre></div>
</div>
<p>If this was a normal Numpy ufunc, we would have seen an exception
complaining that the ufunc couldn’t handle the input types.  When we
call <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code> with integer arguments, not only do we receive an
answer, but we can verify that Numba created a loop supporting C
<code class="code docutils literal notranslate"><span class="pre">long</span></code> integers.</p>
<p>We can add additional loops by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code> with different inputs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">types</span>
<span class="go">[&#39;ll-&gt;l&#39;, &#39;dd-&gt;d&#39;]</span>
</pre></div>
</div>
<p>We can now verify that Numba added a second loop for dealing with
floating-point inputs, <code class="code docutils literal notranslate"><span class="pre">&quot;dd-&gt;d&quot;</span></code>.</p>
<p>If we mix input types to <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code>, we can verify that <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html#casting-rules">Numpy ufunc
casting rules</a> are still in effect:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">types</span>
<span class="go">[&#39;ll-&gt;l&#39;, &#39;dd-&gt;d&#39;]</span>
</pre></div>
</div>
<p>This example demonstrates that calling <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code> with mixed types
caused Numpy to select the floating-point loop, and cast the integer
argument to a floating-point value.  Thus, Numba did not create a
special <code class="code docutils literal notranslate"><span class="pre">&quot;dl-&gt;d&quot;</span></code> kernel.</p>
<p>This <a class="reference internal" href="../reference/jit-compilation.html#numba.DUFunc" title="numba.DUFunc"><code class="xref py py-class docutils literal notranslate"><span class="pre">DUFunc</span></code></a> behavior leads us to a point similar to
the warning given above in “<a class="reference internal" href="#the-vectorize-decorator">The &#64;vectorize decorator</a>” subsection,
but instead of signature declaration order in the decorator, call
order matters.  If we had passed in floating-point arguments first,
any calls with integer arguments would be cast to double-precision
floating-point values.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@vectorize</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">(</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">)</span>
<span class="go">0.66666666666666663</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0.66666666666666663</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">types</span>
<span class="go">[&#39;dd-&gt;d&#39;]</span>
</pre></div>
</div>
<p>If you require precise support for various type signatures, you should
specify them in the <a class="reference internal" href="../reference/jit-compilation.html#numba.vectorize" title="numba.vectorize"><code class="xref py py-func docutils literal notranslate"><span class="pre">vectorize()</span></code></a> decorator, and not rely
on dynamic compilation.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="jitclass.html" class="btn btn-neutral float-right" title="1.7. Compiling Python classes with @jitclass" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="generated-jit.html" class="btn btn-neutral float-left" title="1.5. Flexible specializations with @generated_jit" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2012-2020, Anaconda, Inc. and others

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>